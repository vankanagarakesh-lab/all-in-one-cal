<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<title>Programmer / CS Calculator</title>
<meta name="viewport" content="width=device-width, initial-scale=1.0">

<style>
body{
  margin:0;
  background:#0f1115;
  font-family:system-ui;
  display:flex;
  justify-content:center;
  align-items:center;
  min-height:100vh;
}
.app{
  width:100%;
  max-width:450px;
  background:#15181e;
  color:white;
  padding:20px;
  border-radius: 12px;
  box-shadow: 0 10px 30px rgba(0,0,0,0.5);
  margin: 20px;
}
h2{ text-align:center; opacity:.9; margin-bottom: 20px;}
input,select{
  width:100%;
  padding:12px;
  margin-top:10px;
  background:#1e222b;
  border:1px solid #333;
  color:white;
  border-radius:8px;
  font-size:16px;
  box-sizing: border-box;
}
button{
  width:100%;
  padding:12px;
  margin-top:12px;
  background:#2f80ed;
  border:none;
  color:white;
  font-size:16px;
  font-weight: bold;
  border-radius:8px;
  cursor: pointer;
}
.result{ margin-top:20px; font-size:20px; color: #2f80ed; }
.explain{
  margin-top:15px;
  background:#1e222b;
  padding:15px;
  border-radius:8px;
  font-size:14px;
  line-height:1.6;
  white-space: pre-line;
  border-left: 4px solid #2f80ed;
}
</style>
</head>

<body>

<div class="app">
<h2>üßë‚Äçüíª CS Calculator</h2>

<input id="a" placeholder="First Number (or Decimal/Binary)">
<input id="b" placeholder="Second Number (if needed)">

<select id="op">
  <optgroup label="Bitwise Operators">
    <option value="and">& AND</option>
    <option value="or">| OR</option>
    <option value="xor">^ XOR</option>
    <option value="not">~ NOT</option>
    <option value="lshift">&lt;&lt; Left Shift</option>
    <option value="rshift">&gt;&gt; Right Shift</option>
  </optgroup>

  <optgroup label="Logical Operators">
    <option value="land">&& Logical AND</option>
    <option value="lor">|| Logical OR</option>
    <option value="lnot">! Logical NOT</option>
  </optgroup>

  <optgroup label="Boolean Algebra (0 / 1)">
    <option value="booland">Boolean AND</option>
    <option value="boolor">Boolean OR</option>
    <option value="boolxor">Boolean XOR</option>
  </optgroup>

  <optgroup label="Number Conversion">
    <option value="d2b">Decimal ‚Üí Binary</option>
    <option value="d2o">Decimal ‚Üí Octal</option>
    <option value="d2h">Decimal ‚Üí Hex</option>
    <option value="b2d">Binary ‚Üí Decimal</option>
    <option value="floatbin">Decimal ‚Üí Binary (Float)</option>
  </optgroup>
</select>

<button onclick="calculate()">Calculate Step-by-Step</button>

<div class="result" id="result"></div>
<div class="explain" id="explain"></div>
</div>

<script>
function calculate(){
  let aVal = document.getElementById("a").value;
  let bVal = document.getElementById("b").value;
  let op = document.getElementById("op").value;

  let x = Number(aVal);
  let y = Number(bVal);
  let res="", exp="";

  // Helper for bitwise visualization
  const toBin = (num) => (num >>> 0).toString(2);

  switch(op){
    case "and":
      res = x & y;
      exp = `1. ${x} in binary: ${toBin(x)}\n2. ${y} in binary: ${toBin(y)}\n3. Logic: Keep bits only where both are 1.\nResult: ${toBin(res)} (${res})`;
      break;
    case "or":
      res = x | y;
      exp = `1. ${x} in binary: ${toBin(x)}\n2. ${y} in binary: ${toBin(y)}\n3. Logic: Keep bits where at least one is 1.\nResult: ${toBin(res)} (${res})`;
      break;
    case "xor":
      res = x ^ y;
      exp = `1. ${x} in binary: ${toBin(x)}\n2. ${y} in binary: ${toBin(y)}\n3. Logic: Keep bits where they are different.\nResult: ${toBin(res)} (${res})`;
      break;
    case "not":
      res = ~x;
      exp = `1. ${x} in binary: ${toBin(x)}\n2. Logic: Invert all bits (0 becomes 1, 1 becomes 0).\n3. Formula: -(x + 1)\nResult: ${res}`;
      break;
    case "lshift":
      res = x << y;
      exp = `1. Take ${x} (${toBin(x)})\n2. Shift bits left by ${y} places.\n3. Math: ${x} * 2^${y} = ${res}`;
      break;
    case "rshift":
      res = x >> y;
      exp = `1. Take ${x} (${toBin(x)})\n2. Shift bits right by ${y} places.\n3. Math: floor(${x} / 2^${y}) = ${res}`;
      break;

    case "land":
      res = (x && y) ? 1 : 0;
      exp = `1. Treat non-zero as TRUE, zero as FALSE.\n2. ${x} is ${x?1:0}, ${y} is ${y?1:0}\n3. Logical AND is 1 only if BOTH are non-zero.\nResult: ${res}`;
      break;
    case "lor":
      res = (x || y) ? 1 : 0;
      exp = `1. Treat non-zero as TRUE, zero as FALSE.\n2. Logical OR is 1 if AT LEAST ONE is non-zero.\nResult: ${res}`;
      break;
    case "lnot":
      res = (!x) ? 1 : 0;
      exp = `1. Input is ${x}.\n2. Reverse the truth: If it's 0, it becomes 1. If it's > 0, it becomes 0.\nResult: ${res}`;
      break;

    case "booland":
      res = (aVal === "1" && bVal === "1") ? 1 : 0;
      exp = `Boolean AND (Gate Logic):\n1 AND 1 = 1\nOtherwise = 0\nInputs: ${aVal}, ${bVal}`;
      break;
    case "boolor":
      res = (aVal === "1" || bVal === "1") ? 1 : 0;
      exp = `Boolean OR (Gate Logic):\n0 OR 0 = 0\nOtherwise = 1\nInputs: ${aVal}, ${bVal}`;
      break;
    case "boolxor":
      res = (aVal !== bVal) ? 1 : 0;
      exp = `Boolean XOR (Gate Logic):\n1 if inputs are different.\n0 if inputs are same.\nInputs: ${aVal}, ${bVal}`;
      break;

    case "d2b":
    case "d2o":
    case "d2h":
      let base = (op === "d2b") ? 2 : (op === "d2o") ? 8 : 16;
      res = x.toString(base).toUpperCase();
      let tempX = x;
      exp = `Successive Division by ${base}:\n`;
      while(tempX > 0){
        let rem = tempX % base;
        let hexRem = rem.toString(16).toUpperCase();
        exp += `${tempX} √∑ ${base} = ${Math.floor(tempX/base)} Rem: ${hexRem}\n`;
        tempX = Math.floor(tempX/base);
      }
      exp += `\nRead remainders from bottom to top: ${res}`;
      break;

    case "b2d":
      res = parseInt(aVal, 2);
      exp = `Positional Notation (Binary to Decimal):\n`;
      let digits = aVal.split('').reverse();
      digits.forEach((d, i) => {
        exp += `(${d} * 2^${i}) = ${d * Math.pow(2, i)}\n`;
      });
      exp += `\nSum: ${res}`;
      break;

    case "floatbin":
      let intPart = Math.floor(x);
      let fracPart = x - intPart;
      let bi = intPart.toString(2);
      let bf = "";
      exp = `1. Integer Part: ${intPart} = ${bi}\n2. Fractional Part: ${fracPart.toFixed(4)}\n`;
      let f = fracPart;
      for(let k=0; k<6; k++){
        let old = f;
        f *= 2;
        let bit = Math.floor(f);
        exp += `${old.toFixed(3)} * 2 = ${f.toFixed(3)} (Bit: ${bit})\n`;
        bf += bit;
        f -= bit;
        if(f === 0) break;
      }
      res = bi + "." + bf;
      exp += `\nResult: ${res}`;
      break;
  }

  document.getElementById("result").innerHTML = `<b>Answer:</b> ${res}`;
  document.getElementById("explain").innerText = exp;
}
</script>

</body>
</html>